type Entry {
  id: ID!
  user: User!
  date: String!
  timezone: String!
  content: String
  wordCount: Int
  createdAt: DateTime
  updatedAt: DateTime
  activityLogs: [ActivityLog]
  # tags: [Tag]
}

input DateSpanInput {
  fromDate: DateTime!
  toDate: DateTime
}

type Query {
  findEntryById(id: ID!): Entry
  findEntryByDate(date: String!): Entry
  # findEntriesByMonth(year: Int!, month: Int!): [Entry]
  # findEntriesByYear(year: Int!): [Entry]
  findEntriesByDates(dateSpan: DateSpanInput!): [Entry]
  findAllEntries: [Entry]
  # searchEntriesByContent(searchInput: String!): [Entry]
}

type Mutation {
  createEntry(date: String!, timezone: String!, content: String!, wordCount: Int!, lowestWordCount: Int!, start: DateTime!): Entry
  updateEntry(id: ID!, content: String!, wordCount: Int!, lowestWordCount: Int!, start: DateTime!): Entry
  createOrUpdateEntry(date: String!, timezone: String!, content: String!, wordCount: Int!, lowestWordCount: Int!, start: DateTime!): Entry
}

## BRAINSTORM

type Entry {
  id: ID!
  user: User!
  date: String!
  state: String! # WRITE | EDIT | COMPLETE
  activities: [Activity]
}

type Activity {
  id: ID!
  user: User!
  entry: Entry!
  activityDate: String!
  activityType: String!
  content: String
  wordCount: Int
  lowestWordCount: Int
  start: DateTime
  end: DateTime
  timezone: String
  dayStartsAt: String
}

input CreateEntryInput {
  userId: ID!
  date: String!
  timezone: String!
  dayStartsAt: String!
  start: DateTime!
  content: String!
  wordCount: Int!
}

input CreateEntryActivityInput {
  entryId: ID!
  timezone: String!
  start: DateTime!
  content: String!
  wordCount: Int!

}

type TodayEntryReturn {
  today: Entry
  lastUnedited: Entry
}

type EntryByDate {
  entry: Entry
  editedEntries: [Entry]
}

type EntryGroup {
  entry: Entry # date, state, most recent log -> content, wordCount, type
}

type EntryAnalysis {
  # analysis types
  entry: Entry!
  retrieved: DateTime
}

# add to settings: enableEditing, strictEditing
# Editor scenarios: entry exists, activity is current -> update activity; entry exists, activity is not current -> create activity; entry does not exist -> create entry, create activity

type ActiveDay {
  date: String
  writtenEntry: Entry
  editedEntries: [Entry]
}

# tables: entry, activity, analysis, activity log -> entry many/many table
